{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Configurar ambiente básico do agente",
        "description": "Configurar dependências essenciais para o agente de planos de saúde",
        "details": "Configurar dependências básicas: instalar OpenAI SDK com configuração padrão. Configurar variáveis de ambiente: OpenAI API key. Utilizar infraestrutura Supabase existente sem modificações. Usar embeddings OpenAI text-embedding-3-small. Implementar endpoint básico de verificação de status.",
        "testStrategy": "Testes básicos: verificar instalação das dependências e conexão com OpenAI API. Teste de funcionalidade: validar geração de embeddings simples. Teste manual: verificar se a aplicação inicia corretamente.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalar e configurar SDK da OpenAI",
            "description": "Instalar o SDK oficial da OpenAI e configurar as dependências básicas necessárias para comunicação com a API",
            "dependencies": [],
            "details": "Executar 'npm install openai' para instalar o SDK oficial. Verificar compatibilidade com a versão atual do Node.js do projeto. Importar a biblioteca no código principal e criar uma instância básica do cliente OpenAI.",
            "status": "pending",
            "testStrategy": "Verificar se a instalação foi bem-sucedida executando 'npm list openai'. Testar importação da biblioteca sem erros no código."
          },
          {
            "id": 2,
            "title": "Configurar variáveis de ambiente para API OpenAI",
            "description": "Configurar as variáveis de ambiente necessárias para autenticação com a API da OpenAI",
            "dependencies": [
              "1"
            ],
            "details": "Adicionar OPENAI_API_KEY no arquivo .env existente. Utilizar a mesma estrutura de configuração já presente no projeto. Verificar se a chave está sendo carregada corretamente na aplicação.",
            "status": "pending",
            "testStrategy": "Verificar se a variável de ambiente está sendo carregada. Testar autenticação fazendo uma chamada simples para a API OpenAI."
          },
          {
            "id": 3,
            "title": "Implementar geração básica de embeddings",
            "description": "Criar função simples para gerar embeddings usando o modelo text-embedding-3-small da OpenAI",
            "dependencies": [
              "2"
            ],
            "details": "Criar função que aceita texto como entrada e retorna embeddings usando o modelo text-embedding-3-small. Implementar tratamento básico de erros. Usar a infraestrutura Supabase existente sem modificações.",
            "status": "pending",
            "testStrategy": "Testar com texto de exemplo e verificar se embeddings são gerados corretamente. Validar formato e dimensões do vetor retornado."
          },
          {
            "id": 4,
            "title": "Criar endpoint de verificação de status",
            "description": "Implementar endpoint básico para verificar se o agente está funcionando corretamente",
            "dependencies": [
              "3"
            ],
            "details": "Criar rota GET /health que retorna status da conexão com OpenAI e estado geral do agente. Usar estrutura de rotas já existente no projeto. Retornar resposta JSON simples com status 'ok' ou 'error'.",
            "status": "pending",
            "testStrategy": "Testar endpoint manualmente verificando resposta HTTP 200 e estrutura JSON correta. Validar que retorna erro quando OpenAI não está disponível."
          }
        ]
      },
      {
        "id": 2,
        "title": "Estender schema do banco para planos de saúde",
        "description": "Criar/atualizar tabelas necessárias para suportar o agente de planos de saúde",
        "details": "Executar migrations: ALTER TABLE collections ADD COLUMN chunk_size INT DEFAULT 4000, chunk_overlap INT DEFAULT 200, collection_type TEXT; ALTER TABLE file_items ADD COLUMN plan_metadata JSONB; CREATE INDEX idx_file_items_plan_metadata ON file_items USING gin(plan_metadata); CREATE TABLE health_plan_recommendations com campos: id UUID PRIMARY KEY, workspace_id UUID, user_id UUID, client_info JSONB, analyzed_plans JSONB, recommended_plan JSONB, reasoning TEXT, langsmith_run_id TEXT, created_at TIMESTAMP. Aproveitar tabelas existentes: collections, assistant_collections, file_items, assistant_workspaces.",
        "testStrategy": "Executar migrations localmente, verificar índices criados, testar inserção de dados de exemplo, validar foreign keys e constraints",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Criar assistente especializado em planos de saúde",
        "description": "Configurar assistente dedicado com prompt otimizado e associação às collections de planos",
        "details": "Criar assistente usando sistema existente com configurações específicas: nome 'Agente de Planos de Saúde', modelo GPT-4o, temperatura 0.3, prompt especializado em coleta de informações e recomendação de planos. Associar assistente a collections via assistant_collections. Configurar controle de acesso por workspace via assistant_workspaces apenas para workspaces autorizados. Utilizar sistema existing de criação/gerenciamento de assistentes.",
        "testStrategy": "Criar assistente via interface admin, verificar aparição apenas em workspaces autorizados, testar prompt inicial, validar associação com collections",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implementar sistema RAG configurável para documents",
        "description": "Estender sistema de Collections existente para suportar chunking configurável específico para planos de saúde",
        "details": "Estender interface existente de Collections para adicionar configuração de chunking: campos chunk_size (500-4000 tokens) e chunk_overlap (50-500 tokens). Utilizar LangChain RecursiveCharacterTextSplitter configurável. Implementar reprocessamento automático quando parâmetros de chunk mudarem. Organizar collections por plano: 'plano_unimed_1', 'plano_bradesco_saude', 'collection_geral'. Aproveitar sistema existente de embeddings OpenAI 1536 dims e pgvector.",
        "testStrategy": "Upload PDF de teste, verificar chunking configurável, testar reprocessamento com novos parâmetros, validar embeddings gerados, confirmar busca vetorial funcional",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Desenvolver ferramenta extractClientInfo",
        "description": "Implementar tool que extrai informações do cliente de forma conversacional usando GPT-4o",
        "details": "Criar function tool em /lib/tools/health-plan/extract-client-info.ts que usa GPT-4o para extrair: idade titular, dependentes (relação + idade), condições pré-existentes, medicamentos contínuos, cidade/região, orçamento, preferências. Retornar JSON estruturado com schema validado via Zod. Implementar validação de campos obrigatórios e identificação de informações faltantes. Integrar com Vercel AI SDK para function calling.",
        "testStrategy": "Testar com conversas simuladas, validar extração de JSON, verificar identificação de campos faltantes, confirmar schema Zod, testar casos edge (dependentes múltiplos, condições complexas)",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Desenvolver ferramenta searchHealthPlans",
        "description": "Implementar busca inteligente em múltiplas collections de planos usando RAG",
        "details": "Criar function em /lib/tools/health-plan/search-health-plans.ts que: obtém collections do assistente via assistant_collections, executa busca vetorial em cada collection separadamente usando função existente match_file_items_openai estendida, aplica filtros por metadata (região, operadora), agrega resultados de todas collections, implementa re-ranking por relevância global. Suportar top-K configurável (10-20 por collection). Query otimizada baseada no perfil do cliente.",
        "testStrategy": "Testar busca em múltiplas collections, validar agregação de resultados, verificar re-ranking, confirmar identificação de collection de origem, testar performance < 3s",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Desenvolver ferramenta analyzeCompatibility",
        "description": "Implementar análise de compatibilidade entre perfil do cliente e planos usando GPT-4o",
        "details": "Criar function em /lib/tools/health-plan/analyze-compatibility.ts que usa GPT-4o para: analisar elegibilidade (idade, região, condições), avaliar coberturas relevantes ao perfil, identificar exclusões importantes, calcular score 0-100, gerar justificativa detalhada, identificar alertas críticos (carências, limitações). Processar até 10 planos simultaneamente, retornar ranking ordenado por score.",
        "testStrategy": "Testar com perfis diversos (jovem saudável, família com condições pré-existentes, idoso), validar scores e justificativas, confirmar identificação de alertas críticos, verificar ranking",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Desenvolver integração com API ERP",
        "description": "Implementar ferramenta fetchERPPrices para consultar preços atualizados de planos",
        "details": "Criar function em /lib/tools/health-plan/fetch-erp-prices.ts que: consulta API ERP do cliente com IDs de planos, calcula preços para família (titular + dependentes), implementa cache 15 minutos, retry automático (2 tentativas), timeout 10s, graceful degradation (cache se API falhar). Suporte a headers customizados por cliente. Usar padrão de configuração por workspace para URLs/credenciais da API.",
        "testStrategy": "Testar chamadas API com dados mock, verificar cálculo família, confirmar cache funcionando, testar retry e timeout, validar graceful degradation",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Desenvolver ferramenta generateRecommendation",
        "description": "Implementar geração de recomendação humanizada usando GPT-4o",
        "details": "Criar function em /lib/tools/health-plan/generate-recommendation.ts que gera: recomendação principal + justificativa, alternativas (econômica/premium), comparativo top 3 em tabela Markdown, alertas importantes (carências, exclusões), próximos passos. Usar temperatura baixa (0.1) para consistência, linguagem empática e clara, termos técnicos explicados.",
        "testStrategy": "Testar geração com diferentes perfis, validar formato Markdown, verificar tabelas comparativas, confirmar tom empático, testar explicações de termos técnicos",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Criar orquestrador multi-step",
        "description": "Implementar API route que coordena os 5 passos do processo de recomendação",
        "details": "Criar /app/api/chat/health-plan-agent/route.ts com: execução sequencial dos 5 tools, gerenciamento de estado de sessão, streaming de respostas via Vercel AI SDK, timeout total 60s (Node.js runtime), tratamento de erros por step, logs detalhados, integração com LangSmith para rastreamento. Implementar session-manager.ts para persistir estado entre steps.",
        "testStrategy": "Testar fluxo completo end-to-end, verificar execução sequencial, confirmar streaming, validar timeout, testar tratamento de erros, verificar logs LangSmith",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implementar controle de acesso por workspace",
        "description": "Configurar sistema de permissões para liberar agente apenas para workspaces autorizados",
        "details": "Utilizar sistema existente assistant_workspaces para controle de acesso. Implementar verificação automática no frontend (assistente só aparece se autorizado), validação backend (403 se não autorizado), interface admin para gerenciar workspaces autorizados. RLS do Supabase garante segurança a nível de banco. Aproveitar sistema de permissões existente da aplicação.",
        "testStrategy": "Testar visibilidade apenas em workspaces autorizados, verificar erro 403 para não autorizados, validar interface admin, confirmar RLS funcional",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Desenvolver componentes React especializados",
        "description": "Criar interface especializada para interação com agente de planos de saúde",
        "details": "Criar componentes em /components/health-plan/: health-plan-chat.tsx (wrapper principal), progress-indicator.tsx (barra 5 steps), client-info-card.tsx (resumo info coletadas), plan-comparison.tsx (tabela comparativa), recommendation-panel.tsx (recomendação final). Usar design system existente (Radix UI + Tailwind), compatível com tema escuro/claro, responsivo mobile.",
        "testStrategy": "Testar componentes individualmente, verificar responsividade, validar tema escuro/claro, testar fluxo completo de UI, confirmar acessibilidade",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implementar sistema de auditoria e compliance",
        "description": "Criar sistema de logs para compliance LGPD e auditoria de recomendações",
        "details": "Implementar registro automático em health_plan_recommendations: timestamp, workspace/usuário, informações cliente (anonimizadas se necessário), planos analisados, recomendação + justificativa, preços consultados, langsmith_run_id. Interface de consulta histórico com filtros, exportação CSV, retenção configurável (2 anos default). Criptografia em repouso via Supabase.",
        "testStrategy": "Testar registro automático, verificar anonimização, validar interface consulta, testar exportação, confirmar criptografia, verificar retenção",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Integrar monitoramento LangSmith",
        "description": "Configurar observabilidade completa com LangSmith SDK para rastreamento e análise",
        "details": "Configurar LangSmith SDK: rastreamento todas chamadas LLM (GPT-4o), tracking cada step do orquestrador, métricas (latência por tool, tokens consumidos, custos, taxa sucesso/erro), dashboards performance, alertas para erros/timeouts. Implementar em cada tool individual e no orquestrador principal. Correlation ID para tracking completo da sessão.",
        "testStrategy": "Verificar traces no LangSmith, validar métricas coletadas, testar alertas, confirmar dashboards, verificar correlation entre steps",
        "priority": "medium",
        "dependencies": [
          1,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Criar interface admin para gerenciamento de documentos",
        "description": "Estender interface existing de Collections para gerenciar documentos de planos com chunking configurável",
        "details": "Estender interface existing sidebar Collections: adicionar campos chunk_size/chunk_overlap configuráveis, preview como documentos serão divididos, tags/categorias para collections (plano_specific, geral), status processamento por collection, estatísticas (chunks, tokens, documentos), controle associação assistente ↔ collections. Manter drag-and-drop upload, progress bars, filtros existentes.",
        "testStrategy": "Testar upload com chunking configurável, verificar preview divisão, validar estatísticas, confirmar associação assistente-collections, testar reprocessamento",
        "priority": "low",
        "dependencies": [
          4,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-11T02:16:40.690Z",
      "updated": "2025-11-11T02:16:40.690Z",
      "description": "Tasks for master context"
    }
  }
}